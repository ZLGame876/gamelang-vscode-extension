# GameLang 语言规范

## 概述

GameLang是一门专为游戏开发设计的编程语言，具有以下特点：

### 设计理念
- **极简语法**：语法简洁直观，降低学习门槛
- **中英混合**：支持中文、英文、拼音混合命名
- **游戏导向**：内置游戏开发常用功能
- **跨平台**：支持Windows、Mac、Linux

### 核心特性
- 自动类型推断
- 面向对象编程
- 函数式编程支持
- 丰富的内置函数库
- 模块化支持

## 词法规则

### 标识符
- 支持中文、英文、数字、下划线
- 必须以中文、英文或下划线开头
- 区分大小写
- 支持Unicode字符

```ln
// 有效的标识符
变量名 = 10
userName = "张三"
_私有变量 = true
游戏角色 = 角色()
```

### 保留字
```ln
// 控制流
if, elif, else, while, for, in, break, continue, pass, return

// 函数和类
fn, class

// 模块
import, use, as

// 逻辑运算符
and, or, not

// 字面量
true, false, null, None
```

### 字面量

#### 数字
```ln
整数 = 42
浮点数 = 3.14
负数 = -10
```

#### 字符串
```ln
字符串1 = "Hello World"
字符串2 = "你好世界"
转义字符串 = "第一行\n第二行"
```

#### 布尔值
```ln
真值 = true
假值 = false
```

#### 空值
```ln
空值1 = null
空值2 = None
```

#### 列表
```ln
空列表 = []
数字列表 = [1, 2, 3, 4, 5]
混合列表 = [1, "hello", true, [1, 2, 3]]
```

#### 字典
```ln
空字典 = {}
简单字典 = {"name": "张三", "age": 25}
嵌套字典 = {"user": {"name": "李四", "scores": [90, 85, 88]}}
```

### 注释
```ln
// 单行注释
# 单行注释（Python风格）
/* 多行注释
   可以跨越多行
   支持中文 */
```

## 语法结构

### 程序结构
```ln
// 导入语句
import 模块名;
import 模块名 as 别名;
use "模块文件路径";

// 变量声明
变量名 = 值;

// 函数定义
fn 函数名(参数1, 参数2) {
    // 函数体
    return 返回值;
}

// 类定义
class 类名:
    属性 = 值;
    
    方法名(参数) {
        // 方法体
    }
}
```

### 变量声明
```ln
// 基本声明
变量名 = 值;

// 类型注解（可选）
变量名: 类型 = 值;

// 复合赋值
变量 += 值;
变量 -= 值;
变量 *= 值;
变量 /= 值;
```

### 表达式

#### 算术表达式
```ln
结果 = a + b;      // 加法
结果 = a - b;      // 减法
结果 = a * b;      // 乘法
结果 = a / b;      // 除法
结果 = a % b;      // 取模
结果 = a ** b;     // 幂运算
```

#### 比较表达式
```ln
结果 = a == b;     // 相等
结果 = a != b;     // 不等
结果 = a < b;      // 小于
结果 = a > b;      // 大于
结果 = a <= b;     // 小于等于
结果 = a >= b;     // 大于等于
```

#### 逻辑表达式
```ln
结果 = a and b;    // 逻辑与
结果 = a or b;     // 逻辑或
结果 = not a;      // 逻辑非
```

#### 成员访问
```ln
对象.属性
对象.方法(参数)
列表[索引]
字典[键]
```

### 控制流

#### 条件语句
```ln
if 条件:
    // 条件为真时执行
elif 条件2:
    // 条件2为真时执行
else:
    // 所有条件都为假时执行
}
```

#### 循环语句
```ln
// while循环
while 条件:
    // 循环体
}

// for循环（C风格）
for i in range(10):
    // 循环体
}

// for循环（Python风格）
for 变量 in 可迭代对象:
    // 循环体
}
```

#### 跳转语句
```ln
break;      // 跳出循环
continue;   // 跳过当前迭代
return 值;  // 返回函数值
pass;       // 空操作
```

### 函数定义
```ln
fn 函数名(参数1, 参数2 = 默认值) {
    // 函数体
    return 返回值;
}
```

### 类定义
```ln
class 类名:
    // 类属性
    属性名 = 值;
    
    // 构造函数
    初始化(参数) {
        self.属性 = 参数;
    }
    
    // 方法
    方法名(参数) {
        // 方法体
        return 值;
    }
}
```

### 模块导入
```ln
// 标准导入
import 模块名;
import 模块名 as 别名;

// 简化导入
use 模块名;
use "模块文件路径";
```

## 语义规则

### 类型系统

#### 基本类型
- **int**：整数类型
- **float**：浮点数类型
- **str**：字符串类型
- **bool**：布尔类型
- **None**：空值类型

#### 复合类型
- **list**：列表类型
- **dict**：字典类型
- **自定义类**：用户定义的类类型

#### 类型推断
```ln
a = 10;           // 推断为 int
b = 3.14;         // 推断为 float
c = "hello";      // 推断为 str
d = true;         // 推断为 bool
e = [1, 2, 3];    // 推断为 list
f = {"a": 1};     // 推断为 dict
```

### 作用域规则

#### 全局作用域
- 文件顶层定义的变量、函数、类
- 在整个文件中可见

#### 局部作用域
- 函数内部定义的变量
- 只在函数内部可见

#### 类作用域
- 类内部定义的属性和方法
- 通过对象实例访问

### 对象模型

#### 对象创建
```ln
class 角色 {
    生命值 = 100;
    
    初始化(名字) {
        self.名字 = 名字;
    }
}

// 创建对象
玩家 = 角色("张三");
```

#### 属性访问
```ln
// 直接访问
玩家.生命值 = 80;

// 方法调用
玩家.初始化("李四");
```

#### self关键字
- 在类方法中引用当前对象
- 必须显式使用self访问对象属性

## 错误处理

### 语法错误
- 缺少分号
- 括号不匹配
- 标识符无效

### 运行时错误
- 类型错误
- 除零错误
- 索引越界
- 属性不存在

### 错误提示
```ln
// 友好的错误信息
print("发生错误：", 错误信息);
```

## 文件系统操作

### 文件操作
GameLang提供了丰富的文件系统操作API，支持文件读写、目录管理、系统命令执行等功能。

#### 文件操作函数
```ln
// 文件打开和读写
文件 = open("test.txt", "w");     // 以写入模式打开文件
文件.write("Hello World");        // 写入内容
文件.close();                     // 关闭文件

文件 = open("test.txt", "r");     // 以读取模式打开文件
内容 = 文件.read();               // 读取全部内容
行列表 = 文件.readlines();        // 读取所有行
文件.close();                     // 关闭文件

// 文件管理
remove("test.txt");               // 删除文件
rename("old.txt", "new.txt");     // 重命名文件
exists("test.txt");               // 检查文件是否存在
文件大小 = size("test.txt");      // 获取文件大小
```

## 图形用户界面（GUI）

### 概述
GameLang提供了简单易用的图形用户界面开发能力，基于tkinter实现，支持跨平台运行。

### 窗口操作
```ln
// 创建和操作窗口
创建窗口("我的应用", 800, 600);    // 创建主窗口
设置窗口标题("新标题");            // 设置窗口标题
显示窗口();                       // 显示窗口
隐藏窗口();                       // 隐藏窗口
关闭窗口();                       // 关闭窗口
启动界面();                       // 启动GUI主循环
```

### 基础控件
```ln
// 创建基础控件
按钮控件 = 按钮("点击我");         // 创建按钮
标签控件 = 标签("显示文本");       // 创建标签
输入控件 = 输入框("请输入...");    // 创建输入框
文本控件 = 文本框(40, 10);        // 创建文本框
复选框控件 = 复选框("选项");       // 创建复选框
单选框控件 = 单选框("选项");       // 创建单选框
```

### 布局管理
```ln
// 创建布局容器
垂直布局容器 = 垂直布局();         // 垂直排列控件
水平布局容器 = 水平布局();         // 水平排列控件
网格布局容器 = 网格布局(3, 3);     // 网格排列控件

// 添加控件到布局
添加控件(按钮控件, 垂直布局容器);  // 添加到布局
网格添加(按钮控件, 0, 0, 网格布局容器); // 添加到网格位置
```

### 事件处理
```ln
// 绑定事件（需要先定义回调函数）
fn 按钮点击事件() {
    print("按钮被点击了");
}

绑定点击(按钮控件, 按钮点击事件);   // 绑定点击事件
绑定输入(输入控件, 输入事件);       // 绑定输入事件
```

### 控件属性操作
```ln
// 设置和获取控件属性
设置文本(标签控件, "新文本");      // 设置文本
获取文本(输入控件);                // 获取文本
设置颜色(按钮控件, "red", "white"); // 设置颜色
设置大小(按钮控件, 100, 30);       // 设置大小
```

### 对话框
```ln
// 显示各种对话框
显示消息("标题", "消息内容");      // 信息对话框
显示消息("错误", "错误信息", "error"); // 错误对话框
显示消息("警告", "警告信息", "warning"); // 警告对话框
显示消息("确认", "确认信息", "question"); // 确认对话框

文件名 = 选择文件("选择文件");     // 文件选择对话框
保存路径 = 保存文件("保存文件");   // 文件保存对话框
```

### GUI应用示例
```ln
# 简单的GUI应用
创建窗口("我的应用", 400, 300);

主布局 = 垂直布局();

标题 = 标签("欢迎使用GameLang!");
添加控件(标题, 主布局);

输入框 = 输入框("请输入内容");
添加控件(输入框, 主布局);

按钮 = 按钮("确定");
添加控件(按钮, 主布局);

启动界面();
```

#### 目录操作函数
```ln
// 目录管理
listdir(".");                     // 列出目录内容
mkdir("新目录");                  // 创建目录
rmdir("空目录");                  // 删除空目录
getcwd();                         // 获取当前工作目录
chdir("/path/to/dir");            // 切换目录
```

#### 系统操作函数
```ln
// 系统信息
平台 = platform();                // 获取系统平台
环境变量 = getenv("PATH");        // 获取环境变量

// 命令执行
输出 = system("ls -la");          // 执行系统命令
```

### 文件系统操作最佳实践

#### 错误处理
```ln
// 安全的文件操作
try {
    文件 = open("data.txt", "r");
    内容 = 文件.read();
    文件.close();
} catch (错误) {
    print("文件操作失败:", 错误);
}
```

#### 批量文件处理
```ln
// 批量重命名文件
for (文件名 in listdir(".")) {
    if (exists(文件名) and 文件名.find(".txt") >= 0) {
        新文件名 = "新_" + 文件名;
        rename(文件名, 新文件名);
    }
}
```

#### 文件备份
```ln
// 创建文件备份
源文件 = open("重要文件.txt", "r");
内容 = 源文件.read();
源文件.close();

备份文件 = open("重要文件_备份.txt", "w");
备份文件.write(内容);
备份文件.close();
```

## 人工智能（AI）对话

GameLang提供了强大的人工智能对话功能，支持与AI模型进行交互。

### 基础AI对话

#### ai_对话
基础AI文本对话功能。

```ln
# 基础对话
回复 = ai_对话("你好，请介绍一下自己")
print(回复)

# 指定模型和参数
回复 = ai_对话("写一首诗", "gpt-4", 1024, 0.8)
```

**参数说明：**
- `prompt`: 用户输入的问题
- `模型`: AI模型名称（可选，默认使用配置的模型）
- `最大长度`: 回复的最大长度（可选，默认512）
- `温度`: 创造性参数（可选，默认0.7）

#### ai_智能助手
智能助手对话，支持自定义系统提示。

```ln
# 基础智能助手
回复 = ai_智能助手("帮我写个计算器程序")

# 自定义角色
回复 = ai_智能助手("解释量子物理", "你是一位资深的物理学家")
```

**参数说明：**
- `用户输入`: 用户的问题
- `系统提示`: AI角色设定（可选，默认"你是一个有用的AI助手"）

#### ai_批量对话
批量处理多个问题。

```ln
问题列表 = ["什么是人工智能？", "什么是机器学习？", "什么是深度学习？"]
结果 = ai_批量对话(问题列表)

for 结果项 in 结果 {
    print("问题:", 结果项["问题"])
    print("回答:", 结果项["回答"])
    print("---")
}
```

### AI配置管理

#### ai_设置配置
设置AI相关配置参数。

```ln
# 设置API Key（通过环境变量）
ai_设置配置("openai_api_key", "your-api-key-here")

# 设置模型
ai_设置配置("model", "gpt-4")

# 设置最大长度
ai_设置配置("max_tokens", "1024")

# 设置温度
ai_设置配置("temperature", "0.7")
```

#### ai_获取配置
获取当前AI配置信息。

```ln
配置信息 = ai_获取配置()
print(配置信息)
```

#### ai_测试连接
测试AI连接状态。

```ln
连接状态 = ai_测试连接()
print(连接状态)
```

### 多轮对话/上下文记忆

GameLang支持多轮对话，AI能够记住历史对话内容，实现上下文记忆功能。

#### ai_多轮对话
支持上下文记忆的多轮对话。

```ln
# 初始化对话历史
历史 = []

# 第一轮对话
用户输入 = "你好，你是谁？"
AI回复 = ai_多轮对话(用户输入, 历史)
print("AI:", AI回复)

# 更新历史记录
历史.append({"role": "user", "content": 用户输入})
历史.append({"role": "assistant", "content": AI回复})

# 第二轮对话（AI会记住前面的对话）
用户输入 = "你能帮我写个冒泡排序吗？"
AI回复 = ai_多轮对话(用户输入, 历史)
print("AI:", AI回复)

# 继续更新历史
历史.append({"role": "user", "content": 用户输入})
历史.append({"role": "assistant", "content": AI回复})

# 第三轮对话（AI知道前面讨论的是排序算法）
用户输入 = "请用GameLang语法写"
AI回复 = ai_多轮对话(用户输入, 历史)
print("AI:", AI回复)
```

**参数说明：**
- `用户输入`: 本轮用户的问题
- `历史`: 历史对话记录（可选，默认为空）
- `系统提示`: AI角色设定（可选）

**历史记录格式：**
历史记录是一个列表，每个元素包含：
- `role`: "user"（用户）或"assistant"（AI）
- `content`: 对话内容

#### ai_多轮助手
直接传入完整历史，返回AI回复。

```ln
# 准备完整的历史记录
历史 = [
    {"role": "user", "content": "你好"},
    {"role": "assistant", "content": "你好！我是AI助手，有什么可以帮助你的吗？"},
    {"role": "user", "content": "我想学习编程"}
]

# 获取AI回复
AI回复 = ai_多轮助手(历史, "你是一位耐心的编程老师")
print("AI:", AI回复)
```

**参数说明：**
- `历史`: 完整的对话历史记录
- `系统提示`: AI角色设定（可选）

### 多轮对话GUI应用

GameLang提供了完整的多轮对话GUI应用示例：

```ln
# 创建多轮对话GUI应用
# 详见 examples/AI/多轮对话GUI.ln

# 主要功能：
# - 实时对话界面
# - 自动维护对话历史
# - 支持清空历史
# - 支持保存对话记录
# - 回车键快速发送
```

### 使用建议

1. **API Key配置**：使用前需要设置OPENAI_API_KEY环境变量
2. **历史管理**：及时清理过长的历史记录，避免超出API限制
3. **系统提示**：使用系统提示来设定AI的角色和行为
4. **错误处理**：检查API连接状态，处理网络错误
5. **成本控制**：合理设置max_tokens参数，控制API调用成本

### 示例应用

#### 智能编程助手
```ln
# 创建一个编程助手，记住用户的编程风格和偏好
编程历史 = []
系统提示 = "你是一位经验丰富的程序员，擅长多种编程语言，请用简洁明了的方式回答问题。"

问题 = "如何实现快速排序？"
回复 = ai_多轮对话(问题, 编程历史, 系统提示)
print("编程助手:", 回复)

# 更新历史
编程历史.append({"role": "user", "content": 问题})
编程历史.append({"role": "assistant", "content": 回复})

# 后续问题会基于前面的对话
问题 = "能用Python实现吗？"
回复 = ai_多轮对话(问题, 编程历史, 系统提示)
print("编程助手:", 回复)
```

#### 学习辅导助手
```ln
# 创建一个学习辅导助手
学习历史 = []
系统提示 = "你是一位耐心的老师，善于用通俗易懂的方式解释复杂概念。"

问题 = "什么是递归？"
回复 = ai_多轮对话(问题, 学习历史, 系统提示)
print("老师:", 回复)

# 更新历史
学习历史.append({"role": "user", "content": 问题})
学习历史.append({"role": "assistant", "content": 回复})

# 学生可以继续提问，老师会基于前面的解释
问题 = "能举个具体的例子吗？"
回复 = ai_多轮对话(问题, 学习历史, 系统提示)
print("老师:", 回复)
```

## 最佳实践

### 命名规范
```ln
// 变量和函数使用小驼峰
userName = "张三";
fn getUserInfo() {
    return "用户信息";
}

// 类名使用大驼峰
class GamePlayer {
    // 类定义
}

// 常量使用全大写
MAX_SCORE = 100;
PI = 3.14159;
```

### 代码组织
```ln
// 1. 导入语句
import 数学工具;
use "config.ln";

// 2. 常量定义
游戏配置 = {
    "宽度": 800,
    "高度": 600
};

// 3. 类定义
class 游戏角色 {
    // 类实现
}

// 4. 函数定义
fn 主函数() {
    // 主逻辑
}

// 5. 程序入口
主函数();
```

### 注释规范
```ln
// 文件头部注释
# GameLang 游戏示例
# 作者：开发者
# 功能：实现简单的角色系统

// 函数注释
fn 计算伤害(攻击力, 防御力) {
    // 计算最终伤害值
    // 参数：攻击力 - 攻击方的攻击力
    // 参数：防御力 - 防御方的防御力
    // 返回：最终伤害值
    return max(0, 攻击力 - 防御力);
}

// 行内注释
生命值 = 100;  // 初始生命值
```

## 性能考虑

### 内存管理
- 自动垃圾回收
- 避免循环引用
- 及时释放大对象

### 算法优化
- 使用合适的数据结构
- 避免重复计算
- 优化循环结构

## 兼容性

### 版本兼容
- 向后兼容性保证
- 渐进式功能增强
- 废弃功能警告

### 平台兼容
- Windows支持
- macOS支持
- Linux支持

---

*本规范定义了GameLang语言的完整语法和语义规则，为开发者提供标准参考。* 